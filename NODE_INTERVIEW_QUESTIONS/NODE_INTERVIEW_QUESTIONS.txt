Q.1  Explain in brief what is node js?
Sol: Node.js is an open-source, cross-platform JavaScript runtime environment and library to run web applications outside the client’s browser. 
     It is used to create server-side web applications.
     Features of NodeJS: 
     i) It’s easy to get started.
     ii) It provides fast and highly scalable services.
     iii) It uses JavaScript everywhere, so it’s easy for a JavaScript programmer to build back-end services using Node.js
     iv) Source code cleaner and consistent.
     v) Large ecosystem for open source library.
     vi) It has Asynchronous or Non-blocking nature.

Q.2  How is node js non-blocking?
sol: Node.js is based on an event-driven non-blocking I/O model. It refers to the program that does not block the execution of further operations. 
     Non-Blocking methods are executed asynchronously. 
     Asynchronously means that the program may not necessarily execute line by line. The program calls the function and move to the next operation 
     and does not wait for it to return.

Q.3  What is throughput?
Sol: Throughput tells you how much data was transferred from a source at any given time.

Q.4  How is Node js having high IO throughput?
Sol: i) Node.js is asynchronous and single-threaded. This means that all I/O operations don’t block any other operations. It also means that you can send emails, read files, query the database, etc. all at the same time.
     ii) Each request to the web-server won’t create a separate Node.js process. Although, one Node.js process would run at all times which would listen to the connections. JavaScript code is also executed in the process’ 
         thread while all other I/O operations are executed in separate threads which results in almost no delays.
     iii) The virtual machine in Node.js (V8) which is responsible for executing JavaScript consists of a JIT compilation. The virtual machine can take the source code to compile it into the machine code at runtime. 
         It means that all the “hot” functions that get called often than not can be compiled to the machine code thus boosting the execution speed.

Q.5  What are CPU intensive tasks?
Sol: They are complex user actions that eat up more RAM. A few of such processes can shut down your server entirely.
     Handling CPU Intensive tasks:
     i) More Powerful server
     ii) Additional server
     iii) Separate instance for each task
     iv) AWS Lamba

Q.6 How can you end up blocking your main thread in node.js?
Sol:Node.js uses a small number of threads to handle many clients. In Node.js there are two types of threads: one Event Loop (aka the main loop, main thread, event thread, etc.), and a pool of k Workers in a Worker Pool (aka the threadpool).
    If a thread is taking a long time to execute a callback (Event Loop) or a task (Worker), we call it "blocked". While a thread is blocked working on behalf of one client, it cannot handle requests from any other clients. 
    This provides two motivations for blocking neither the Event Loop nor the Worker Pool:
    i) Performance: If you regularly perform heavyweight activity on either type of thread, the throughput (requests/second) of your server will suffer.
    ii) Security: If it is possible that for certain input one of your threads might block, a malicious client could submit this "evil input", make your threads block, and keep them from working on other clients. This would be a Denial of Service attack.

Q.7 What is the event loop?
Sol:The event loop allows Node.js to perform non-blocking I/O operations despite the fact that JavaScript is single-threaded. It is done by assigning operations to the operating system whenever and wherever possible.
    Features of Event Loop:
    i) Event loop is an endless loop, which waits for tasks, executes them and then sleeps until it receives more tasks.
    ii) The event loop executes tasks from the event queue only when the call stack is empty i.e. there is no ongoing task.
    iii) The event loop allows us to use callbacks and promises.
    iv) The event loop executes the tasks starting from the oldest first.

Q.8 What are different phases in event loop?
Sol:When Node.js finished executing the index.js in the main thread, the Node.js event loop starts to execute the callbacks registered during the main thread’s runtime.
    Callback queue: There’s a callback queue in each phase that stores callbacks to be executed in that phase. It’s very similar to the Task queue provided by a browser.
    i) Timers: This is the first phase in the event loop. It finds expired timers in every iteration (also known as Tick) and executes the timers callbacks created by setTimout and setInterval.
    ii) 
    ii) Pending callbacks: It handles I/O callbacks deferred to the next iteration, such as handling TCP socket connection error.
    iii) Idle, prepare: It’s only used internally.
    iv) Poll: The Poll phase calculates the blocking time in every iteration to handle I/O callbacks. In this phase, the epoll_wait() system call is invoked (in Linux).
    v) Check: This phase handles the callbacks scheduled by setImmediate(), and the callbacks will be executed once the Poll phase becomes idle.
    vi) Close Callback: This phase handles callbacks if a socket or handle is closed suddenly and the ‘close’ event will be emitted.
    vii) The microtask queue: Microtasks are executed after the main thread and each phase of the event loop. Microtasks created by process.nextTick() are executed before those created by then() and catch().

Q.9 What is process.tick?
Sol:The process object is one of the few global objects provided by the NodeJS core API. It can be accessed from anywhere, thus its methods can also be accessed. Such is a method called process.nextTick() 
    which is used by developers in real-time applications every day to defer the execution of a function until the next Event Loop Iteration.

Q.10 